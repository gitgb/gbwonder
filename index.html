<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Gbwonder by gitgb</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>gbWonder</h1>
        <p>gb's extensions to wonder</p>

        <p class="view"><a href="https://github.com/gitgb/gbwonder">View the Project on GitHub <small>gitgb/gbwonder</small></a></p>


        <ul>
          <li><a href="https://github.com/gitgb/gbwonder/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/gitgb/gbwonder/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/gitgb/gbwonder">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <h3>Welcome to gbWonder</h3>

<p>This repo holds extensions to Wonder, perhaps not incorporated into the main wonder repo.</p>

<h3>ERBatchfixes</h3>

This ERBatchFixes framework allows you to have your application do batch jobs at startup time. Often after database migrations there may be needed modifications to the data in the database. This package allows you to more easily create these changes through a batch job, run after a migration, but before your application starts up. These jobs are remembered in a _ERBatchFixes db table. Also, a log4j logger is setup so you can log during the batch job, and this log is stored with the batch job info, as is start time, end time. To use this, create a subclass of ERBatchFixesParent, which you will then use to do whatever batch jobs/processing you want. The ERBatchFixesParent handles storing fix event information for you; things like: has the fix been applied, when? the error log, etc. ERMigrations is used to create the db table _ERBatchFixes. <br/>
To use this do 3 things:<ul type="square"><li>
1. Make your fixer-upper class extend ERBatchFixesParent.</li><li>
2. Modify your Application's didFinishLaunching() method to create and call your fixer class,</li><li>
3. and modify your Application's Properties so memory of the changes will persist.</li></ul>
The intent is to run this batch job right after your app is finished initializing. Use something like:

<pre><code>public void   didFinishLaunching(){ // method in Application

        // All setup? lets fix/patchup our own lists of fixes
        String fixname = "MyFixes";
        try {
                MyFixes fn = new MyFixes(); // MyFixes is subclass of ERBatchFixesParent        
                if( fn.isReadyToDo() ){ // wise to check if it is ok
                        fn.doit(); // do the fix(es)
        }       
        } catch (ERBatchFixFinished e) {
                log.info("Fix is alredy finished: " + fixname, e);
        } catch (IllegalStateException e) {
                log.info("ERBatchFixes turned off by system property");
        } catch (Exception e) {
      log.error("Error during fix " + fixname, e);
  }
}</code></pre>

The fixes will be remembered (along with an error log) in a chosen database. Set up your Properties to point to the DB where you want the fix events persisted:
<pre><code># these migrations happen after main program initialization but before batch fixes..
er.migration.migrateAtStartup=true
er.migration.createTablesIfNecessary=true
er.migration.modelNames=ERBatchFixes,myOtherModels,etc
ERBatchFixes.MigrationClassPrefix=er.batchfixes.migrations.ERBatchFixes

# property must be true to use this
er.batchfixes.dofixes = true
ERBatchFixes.URL = jdbc:FrontBase://localhost/MyDBProduction
ERBatchFixes.DBUser = _system
ERBatchFixes.DBPassword = 
ERBatchFixes.DBDriver =
ERBatchFixes.DBPlugin =
ERBatchFixes.DBJDBCInfo =
</code></pre>
<p>
This framework will create a _ERBatchFixes table, via migrations to store fix event information. With multiple applications., it is best to run one instance of your app to do the fixes, then run with all instances. As ERXJDBCMigrationLock says: "if true, the tables and model rows will be created automatically. *ONLY SET THIS IF YOU ARE RUNNING IN DEVELOPMENT MODE OR WITH A SINGLE INSTANCE*. If you are running multiple instances, the instances will not be able to acquire locks properly and you may end up with multiple instances attempting to create lock tables and/or failing to startup properly.
</p>

<h3>Authors and Contributors</h3>

<p> </p>

      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/gitgb">gitgb</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>